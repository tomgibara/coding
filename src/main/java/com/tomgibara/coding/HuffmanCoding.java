/*
 * Copyright 2007 Tom Gibara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.tomgibara.coding;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.PriorityQueue;

import com.tomgibara.bits.BitReader;
import com.tomgibara.bits.BitStreamException;
import com.tomgibara.bits.BitWriter;
import com.tomgibara.bits.Bits;

/**
 * An implementation of Huffman coding. This is an optimized implementation that
 * accelerates encoding through canonicalization and reads bits in blocks to
 * speed up decoding.
 *
 * Huffman codings can be constructed in one of two ways. Either via
 * {@link Frequencies} (a couple convenient implementations are provided by this
 * class {@link UnorderedFrequencies} and {@link DescendingFrequencies})
 * or using a {@link Dictionary}.
 *
 * Every Huffman coding exposes a dictionary which stores the minimum data
 * necessary to reconstruct it. By faithfully transmitting this dictionary,
 * applications can be sure that the Huffman encoded values will decode
 * correctly.
 *
 * Note that only values with non-zero frequencies can be encoded/decoded.
 *
 * @author Tom Gibara
 * @see <a href="http://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a>
 */

//TODO could define equality based on equality of dictionaries
public class HuffmanCoding implements Coding {

	// statics

	/**
	 * Provides a mapping between a set of non-negative integers and
	 * [0..size-1]. The information provided through this interface is used to
	 * correctly encode and decode values. It is exposed via the
	 * {@link Dictionary}.
	 */

	public interface Correspondence {

		/**
		 * The number of distinct values that can be encoded. Note that values
		 * with zero frequency cannot be included and are therefore not counted.
		 *
		 * @return the number of values, non-negative
		 */

		int getCount();

		/**
		 * The index of the specified value.
		 *
		 * @param value
		 *            a positive number
		 * @return the (zero-based) index of the value
		 * @throws IllegalArgumentException
		 *             if the value cannot be encoded
		 */

		int getIndex(int value) throws IllegalArgumentException;

		/**
		 * The value at the specified index.
		 *
		 * @param index
		 *            a (zero-based) index of a value
		 * @return the value at the index
		 * @throws IllegalArgumentException
		 *             if there is no value at the specified index
		 */

		int getValue(int index) throws IllegalArgumentException;

	}

	/**
	 * Dictionaries encapsulate the information required to reconstruct an
	 * equivalent {@link HuffmanCoding}.
	 *
	 * @see HuffmanCoding#getDictionary()
	 */

	public interface Dictionary {

		/**
		 * The correspondence
		 * @return a correspondence
		 */

		Correspondence getCorrespondence();

		/**
		 * The longest bit-length of any codeword generated by a particular
		 * {@link HuffmanCoding}.
		 *
		 * @return the number of bits in the longest codeword
		 */

		int getMaximumCodeLength();

		/**
		 * The number of codewords that have the specified length
		 *
		 * @param codeLength
		 *            some number of bits
		 * @return the number of codewords that contain the specified number of
		 *         bits, may be zero
		 */

		int getCodeLengthCount(int codeLength);

	}

	/**
	 * Provides the frequency information required to establish a Huffman
	 * coding. The information is split into two parts. A non-strict
	 * monotonically decreasing sequence of non-zero frequencies, and a correspondence
	 * between the index of these frequencies and the values they rank.
	 */

	public interface Frequencies {

		/**
		 * The number of values that occur at least once.
		 *
		 * @return the number of (non-zero) frequencies.
		 */

		int getCount();

		/**
		 * The frequency at a particular index. Frequencies are monotonically
		 * decreasing with respect to the index. In other words i &lt; j implies
		 * freq_i &gt;= freq_j.
		 *
		 * @param index
		 *            a non-negative number not meeting or exceeding the count
		 * @return the frequency at the specified index
		 */

		long getFrequency(int index);

		/**
		 * A correspondence between the frequencies at an index and the values
		 * they correspond to.
		 *
		 * @return a correspondence between the indices of frequencies and the
		 *         values they represent
		 */

		Correspondence getCorrespondence();

	}

	private static class DirectCorrespondence implements Correspondence {

		private final int count;

		DirectCorrespondence(int count) {
			this.count = count;
		}

		@Override
		public int getCount() {
			return count;
		}

		@Override
		public int getIndex(int value) {
			if (value < 0) throw new IllegalArgumentException("negative value");
			if (value >= count) throw new IllegalArgumentException("invalid value");
			return value;
		}

		@Override
		public int getValue(int index) {
			if (index >= count) throw new BitStreamException("invalid huffman encoding: " + index);
			return index;
		}

	}

	private static class DenseCorrespondence implements Correspondence {

		private final int[] values;
		private final int[] indices;

		DenseCorrespondence(int[] values, int[] indices) {
			this.values = values;
			this.indices = indices;
		}

		@Override
		public int getCount() {
			return values.length;
		}

		@Override
		public int getIndex(int value) {
			if (value < 0) throw new IllegalArgumentException("negative value");
			if (value >= indices.length) throw new IllegalArgumentException("invalid value: " + value);
			int index = indices[value];
			if (index < 0) throw new IllegalArgumentException("invalid value: " + value);
			return index;
		}

		public int getValue(int index) {
			if (index >= values.length) throw new BitStreamException("invalid huffman encoding: " + index);
			return values[index];
		}

	}

	/**
	 * Stores a pre-sorted, descending sequence of frequencies. Instances of
	 * this class can be used to construct a {@link HuffmanCoding} for values
	 * that have already been ranked by frequency.
	 */

	public static class DescendingFrequencies implements Frequencies {

		private final long[] frequencies;
		private final int count;

		/**
		 * Constructs an instance from a pre-sorted (descending) array of
		 * frequency values. The supplied array may contain zeros, but may not
		 * contain negative values, and must be decreasingly ordered.
		 *
		 * @param frequencies
		 *            an array of frequencies
		 */

		public DescendingFrequencies(long... frequencies) {
			if (frequencies == null) throw new IllegalArgumentException("null frequencies");
			int length = frequencies.length;
			int count = length;
			long previous = Long.MAX_VALUE;
			for (int i = 0; i < frequencies.length; i++) {
				long freq = frequencies[i];
				if (freq < 0) throw new IllegalArgumentException("negative frequency");
				if (freq > previous) throw new IllegalArgumentException("frequencies not monotonically descending");
				if (freq == 0 && count == length) count = i;
			}
			this.frequencies = frequencies;
			this.count = count;
		}

		@Override
		public int getCount() {
			return count;
		}

		@Override
		public long getFrequency(int index) {
			return frequencies[index];
		}

		@Override
		public Correspondence getCorrespondence() {
			return new DirectCorrespondence(count);
		}

	}

	/**
	 * Generates a descending sequence of frequencies. Instances of
	 * this class can be used to construct a {@link HuffmanCoding} for values
	 * that have not already been ranked by frequency.
	 */

	public static class UnorderedFrequencies implements Frequencies {

		private final long[] frequencies;
		private final Correspondence correspondence;

		/**
		 * Constructs an instance from an unordered array of frequencies. The
		 * supplied array may contain zeros, but may not contain negative
		 * values.
		 *
		 * @param frequencies
		 *            an array of frequencies
		 */

		public UnorderedFrequencies(long... frequencies) {
			if (frequencies == null) throw new IllegalArgumentException("null frequencies");
			int count = frequencies.length;
			El[] els = new El[count];
			for (int i = 0; i < count; i++) {
				els[i] = new El(i, frequencies[i]);
			}
			Arrays.sort(els);
			//TODO could use binary search?
			int limit;
			for (limit = 0; limit < count; limit++) {
				if (els[limit].freq == 0) break;
			}

			frequencies = new long[limit];
			//TODO support 'non-dense' lookups
			int[] values = new int[limit];
			int[] indices = new int[count];
			for (int i = 0; i < count; i++) {
				El el = els[i];
				if (i < limit) {
					frequencies[i] = el.freq;
					int j = el.index;
					values[i] = j;
					indices[j] = i;
				} else {
					indices[el.index] = -1;
				}
			}

			this.frequencies = frequencies;
			correspondence = new DenseCorrespondence(values, indices);
		}

		@Override
		public int getCount() {
			return frequencies.length;
		}

		@Override
		public long getFrequency(int index) {
			return frequencies[index];
		}

		@Override
		public Correspondence getCorrespondence() {
			return correspondence;
		}

		private static class El implements Comparable<El> {

			int index;
			long freq;

			El(int index, long freq) {
				this.index = index;
				this.freq = freq;
			}

			@Override
			public int compareTo(El that) {
				if (this.freq == that.freq) return 0;
				return this.freq < that.freq ? 1 : -1;
			}

		}

	}

	private static Node buildTree(PriorityQueue<Node> nodes) {
		while(true) {
			Node node1 = nodes.poll();
			Node node2 = nodes.poll();
			if (node2 == null) return node1;
			Node node = new Node(node1, node2);
			nodes.add(node);
		}
	}

	private static Node[] createNodes(Frequencies frequencies) {
		final int count = frequencies.getCount();
		PriorityQueue<Node> nodes = new PriorityQueue<Node>(count);
		Node[] array = new Node[count];
		long lastFreq = 0L;
		for (int i = 0; i < count; i++) {
			long freq = frequencies.getFrequency(i);
			if (i > 0 && lastFreq < freq) throw new IllegalArgumentException("frequencies not descending at index " + i);
			Node leaf = new Node(freq);
			array[i] = leaf;
			nodes.add(leaf);
			lastFreq = freq;
		}
		buildTree(nodes);
		return array;
	}

	private static int[] calculateLengths(Node[] nodes) {
		int[] lengths = new int[nodes.length];
		for (int i = 0; i < nodes.length; i++) {
			lengths[i] = nodes[i].getLength();
		}
		return lengths;
	}

	private static int[] countLengths(int[] lengths) {
		int maxLen = 0;
		int[] count = new int[16];
		for (int length : lengths) {
			if (length >= maxLen) {
				if (length >= count.length) {
					int newLen = Math.max(length + 1, 2 * count.length);
					int[] tmp = new int[newLen];
					System.arraycopy(count, 0, tmp, 0, maxLen+1);
					count = tmp;
				}
				maxLen = length;
			}
			count[length] ++;
		}
		int[] ret = new int[maxLen + 1];
		System.arraycopy(count, 0, ret, 0, maxLen+1);
		return ret;
	}

	private static int[] accumulateCounts(int[] counts) {
		int[] cumm = new int[counts.length];
		int c = 0;
		for (int i = 0; i < counts.length; i++) {
			c += counts[i];
			cumm[i] = c;
		}
		return cumm;
	}

	private static int[] encodeCounts(int[] counts) {
		int[] codes = new int[counts.length];
		int l = 0;
		for (int i = 1; i < counts.length; i++) {
			int count = counts[i];
			if (count == 0) continue;
			codes[i] = (codes[l] + counts[l]) << (i - l);
			l = i;
		}
		return codes;
	}

	// fields

	private final Correspondence correspondence;
	private final int[] counts;
	private final int[] codes;
	private final int[] cumm;
	private final Nid root;
	private final Dictionary dictionary;

	// constructors

	/**
	 * Constructs a coding based on the frequencies supplied.
	 *
	 * @param frequencies
	 *            information about value frequencies
	 */

	public HuffmanCoding(Frequencies frequencies) {
		if (frequencies == null) throw new IllegalArgumentException("null frequencies");
		correspondence = frequencies.getCorrespondence();
		Node[] nodes = createNodes(frequencies);
		int[] lengths = calculateLengths(nodes);
		counts = countLengths(lengths);
		codes = encodeCounts(counts);
		cumm = accumulateCounts(counts);
		root = produceNids();
		root.computeLeastHeights();
		root.computeLookups();
		dictionary = new HuffmanDictionary(correspondence, counts);
	}

	/**
	 * Constructs a coding based on a dictionary. The data contained in a
	 * dictionary (if not the dictionary itself) will generally have originated
	 * in another instance of this class.
	 *
	 * @param dictionary
	 *            the minimal information needed to construct an instance of this class
	 */

	public HuffmanCoding(Dictionary dictionary) {
		if (dictionary == null) throw new IllegalArgumentException("null dictionary");
		this.dictionary = dictionary;
		this.correspondence = dictionary.getCorrespondence();
		if (correspondence == null) throw new IllegalArgumentException("no correspondence");
		int maxLength = dictionary.getMaximumCodeLength();
		if (maxLength < 0) throw new IllegalArgumentException("negative maximum code length");
		int[] counts = new int[maxLength + 1];
		for (int i = 1; i <= maxLength; i++) {
			int count = dictionary.getCodeLengthCount(i);
			if (count < 0) throw new IllegalArgumentException("negative code length count");
			counts[i] = count;
		}
		this.counts = counts;
		codes = encodeCounts(counts);
		cumm = accumulateCounts(counts);
		root = produceNids();
		root.computeLeastHeights();
		root.computeLookups();
	}

	// accessors

	/**
	 * A dictionary that can be used to construct an equivalent instance of this
	 * class.
	 *
	 * @return the dictionary for this coding
	 */

	public Dictionary getDictionary() {
		return dictionary;
	}

	// methods

	/**
	 * The number of bits that would be written to encode a value. This method
	 * may be useful for calculating storage sizes prior to encoding.
	 *
	 * @param value
	 *            a non-negative integer with a recorded frequency of at least
	 *            one
	 * @return the bit length of a value's encoding
	 */

	public int getCodeLength(int value) {
		return getCodeLengthForIndex(correspondence.getIndex(value));
	}

	/**
	 * The number of bits that would be written to encode the number of values
	 * indicated by the supplied frequencies. This may be useful for calculating
	 * storage sizes prior to encoding.
	 *
	 * @param frequencies
	 *            a count of how many of each value to be encoded
	 * @return the total bit length of all value encodings
	 */

	public long getEncodedLength(Frequencies frequencies) {
		int count = frequencies.getCount();
		long length = 0L;
		for (int i = 0; i < count; i++) {
			length += frequencies.getFrequency(i) * getCodeLength(frequencies.getCorrespondence().getValue(i));
		}
		return length;
	}

	// coding methods

	@Override
	public int encodePositiveInt(BitWriter writer, int value) {
		return unsafeEncodePositiveInt(writer, value);
	}

	@Override
	public int encodePositiveLong(BitWriter writer, long value) {
		return unsafeEncodePositiveInt(writer, (int) value);
	}

	@Override
	public int encodePositiveBigInt(BitWriter writer, BigInteger value) {
		if (value.compareTo(BigInteger.valueOf(correspondence.getCount())) > 0) throw new IllegalArgumentException("value exceeds number of symbols");
		return unsafeEncodePositiveInt(writer, value.intValue());
	}

	public int decodePositiveInt(BitReader r) {
		Nid nid = root;
		while (nid.index == -1) {
			// simple but slower, using lookup is about 25% faster overall
			//nid = r.readBoolean() ? nid.one: nid.zero;
			nid = nid.lookup[ r.read(nid.leastHeight) ];
		}
		return correspondence.getValue(nid.index);
	}

	@Override
	public long decodePositiveLong(BitReader reader) {
		return decodePositiveInt(reader);
	}

	@Override
	public BigInteger decodePositiveBigInt(BitReader reader) {
		return BigInteger.valueOf(decodePositiveInt(reader));
	}

	private int unsafeEncodePositiveInt(BitWriter writer, int value) {
		return encodeIndex(writer, correspondence.getIndex(value));
	}

	private int encodeIndex(BitWriter writer, int index) {
		int x = getCodeLengthForIndex(index);
		if (x > 0) writer.write(codes[x] + index - cumm[x - 1], x);
		return x;
	}

	private int getCodeLengthForIndex(int index) {
		if (cumm.length == 1) return 0;
		int x = Arrays.binarySearch(cumm, index + 1);
		//we may not have an exact match
		if (x < 0) x = - 1 - x;

		//check value
		if (x == 0) throw new IllegalArgumentException();
		//if (x == cumm.length) throw new IllegalArgumentException();
		//TODO what's the fix?
		if (x == cumm.length) x--;

		//we may have missing lengths == dups in cumm
		while( x > 1 && cumm[x] == cumm[x - 1] ) x--;

		return x;
	}

	private Nid produceNids() {
		int[] ints = new int[codes.length];
		BitWriter w = Bits.writerTo(ints);
		BitReader r = Bits.readerFrom(ints);
		//IntArrayBitWriter w = new IntArrayBitWriter(codes.length);
		//IntArrayBitReader r = new IntArrayBitReader(w.getInts());
		Nid root = new Nid();
		int count = correspondence.getCount();
		for (int i = 0; i < count; i++) {
			w.setPosition(0);
			int length = encodeIndex(w, i);
			w.flush();
			r.setPosition(0);
			Nid nid = root;
			for (int j = 0; j < length; j++) {
				int bit = r.readBit();
				Nid n;
				if (bit == 0) {
					n = nid.zero;
					if (n == null) {
						n = new Nid();
						nid.zero = n;
					}
				} else {
					n = nid.one;
					if (n == null) {
						n = new Nid();
						nid.one = n;
					}
				}
				nid = n;
			}
			nid.index = i;
		}
		return root;
	}

	private static class Node implements Comparable<Node> {

		final long freq;
		int length;
		Node parent;

		Node(long freq) {
			this.freq = freq;
			this.length = -1;
		}

		Node(Node left, Node right) {
			left.parent = this;
			right.parent = this;
			freq = left.freq + right.freq;
			length = 0;
		}

		int getLength() {
			if (length <= 0) {
				length = parent == null ? 0 : parent.getLength() + 1;
			}
			return length;
		}

		public int compareTo(Node that) {
			if (this.freq < that.freq) return -1;
			if (this.freq > that.freq) return 1;
			if (this.length < that.length) return -1;
			if (this.length > that.length) return 1;
			return 0;
		}

	}

	private static class Nid {

		int index = -1;
		Nid zero;
		Nid one;
		int leastHeight;
		Nid[] lookup;

		void computeLeastHeights() {
			if (zero == null || one == null) {
				leastHeight = 0;
			} else {
				one.computeLeastHeights();
				zero.computeLeastHeights();
				leastHeight = 1 + Math.min(zero.leastHeight, one.leastHeight);
			}
		}

		void computeLookups() {
			if (leastHeight == 0) return;
			int length = 1 << leastHeight;
			lookup = new Nid[length];
			for (int i = 0; i < length; i++) {
				Nid n = this;
				for (int b = leastHeight - 1; b >= 0; b--) {
					n = ((i >> b) & 1) == 0 ? n.zero : n.one;
				}
				n.computeLookups();
				lookup[i] = n;
			}
		}

		@Override
		public String toString() {
			//return index == -1 ? "(zero: " + zero + "  one: " + one + ")" : Integer.toString(index);
			return lookup == null ? index == -1 ? "(zero: " + zero + "  one: " + one + ")" : Integer.toString(index) : Arrays.toString(lookup);
		}

	}

	private static class HuffmanDictionary implements Dictionary {

		private final Correspondence correspondence;
		private final int[] counts;

		HuffmanDictionary(Correspondence correspondence, int[] counts) {
			this.correspondence = correspondence;
			this.counts = counts;
		}

		@Override
		public Correspondence getCorrespondence() {
			return correspondence;
		}

		@Override
		public int getMaximumCodeLength() {
			return counts.length - 1;
		}

		@Override
		public int getCodeLengthCount(int codeLength) {
			if (codeLength <= 0) throw new IllegalArgumentException("non-positive codeLength");
			return counts[codeLength];
		}

	}

}
